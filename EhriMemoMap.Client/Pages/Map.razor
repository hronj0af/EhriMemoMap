@* @page "/map" *@
@page "/{City}"

@using NetTopologySuite.Geometries;
@inject IJSRuntime JS
@inject DialogService DialogService
@inject IStringLocalizer<CommonResources> cl
@inject MapService MapService

@if (MapService.AppState != AppStateEnum.Shutdown)
{

    <div id="map" style="cursor:default;">
        <!-- TOTO JE FILTR, KTERÝ SE POUŽÍVÁ PRO HEZČÍ VYKRESLENÍ HRANIC OKRESŮ,
        RESP. CELÉ PRAHY (viz soubor site.css, řádek div.leaflet-overlay-pane svg > g path.statistics-polygon) -->
        <svg xmlns="w3.org/2000/svg" ; version="1.1">
            <defs>
                <filter id='inset-shadow'>
                    <feOffset dx='0' dy='0' />
                    <feGaussianBlur stdDeviation='5' result='offset-blur' />
                    <feComposite operator='out' in='SourceGraphic' in2='offset-blur' result='inverse' />
                </filter>
            </defs>
        </svg>
    </div>

    <ControlButtonsWrapper />
    <ZoomButtonsWrapper />
    <ContextButtonsWrapper />
    <TimelineMapWrapper />
    <MobileTopBarWrapper />
}


@code {
    bool? isMobileView = null;
    bool firstRender = true;
    string? selectedPointGuidsJson;

    [Parameter]
    public string? City { get; set; }

    public async override Task SetParametersAsync(ParameterView parameters)
    {
        await base.SetParametersAsync(parameters);
        City = City ?? "prague";
    }

    /// <summary>
    /// Initialiazece mapy se děje až po prvním renderu, protože až v tomto okamžiku mám k dispozici všechny potřebné informace
    /// </summary>
    /// <param name="firstRender"></param>
    /// <returns></returns>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        this.firstRender = firstRender;

        if (firstRender && !MapService.MapStateWasInit)
        {
            // tady se zjistí šířka a výška okna kvůli zobrazení dialogového okna s dalšími informacemi
            MapService.WindowWidth = await JS.InvokeAsync<int>("mapAPI.getWindowWidth");
            MapService.WindowHeight = await JS.InvokeAsync<int>("mapAPI.getWindowHeight");

            // zjistím, jestli se jedná o mobilní zařízení
            MapService.IsMobileView = await JS.InvokeAsync<bool>("mapAPI.isMobileView");
            isMobileView = MapService.IsMobileView;

            // musím do javascriptu šoupnout odkaz na instanci téhle třídy Map,
            // abych pak mohl z javascriptu volat metodu RefreshObjectsOnMap a ShowPlaceInfo
            var dotNetReference = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("mapAPI.initBlazorMapObject", dotNetReference, "Map");

            // získám parametry z url o vrstvách, bodu na časové ose a ohraničení mapy
            string layers = await JS.InvokeAsync<string>("mapAPI.getUrlParam", "layers");
            string timelinePointName = await JS.InvokeAsync<string>("mapAPI.getUrlParam", "timeline");


            // inicializace hlavního objektu mapy
            // pokud jsou v url parametry layers a timeline, tak se použijí, jinak se použijí defaultní hodnoty
            await MapService.Init(City, layers, timelinePointName);
            await MapService.GetAllNarrativeMaps();

            string? bounds = await JS.InvokeAsync<string>("mapAPI.getUrlParam", "bounds");

            if (MapService.AppState == AppStateEnum.Shutdown)
            {
                DialogService.Open<Error>(" ", options: new DialogOptions { ShowClose = false, ShowTitle = false, CloseDialogOnOverlayClick = false, Width = "720px" });
                return;
            };

            var coordinates = await GetCoordinatesFromUrl();
            var mapZoom = (int)decimal.Parse(await JS.InvokeAsync<string>("mapAPI.getUrlParam", "zoom") ?? "0");

            // pokud není v url parametr bounds (uživatel s mapou ještě nezačal pracovat), 
            // a nejsou zadané koordináty pro zobrazení určitého místa
            // tak se zobrazí dialog s vysvětlením, jak se v mapě pohybovat
            // pokud už s mapou začal pracovat, tak ho s tímto uvítacím dialogem nebudeme otravovat
            if (string.IsNullOrEmpty(bounds) && coordinates == null)
                if (!MapService.IsMobileView)
                    DialogService.Open<Welcome>(" ", options: new DialogOptions { ShowClose = false, ShowTitle = false, CloseDialogOnOverlayClick = true, Width = "720px" });
                else
                    await MapService.SetDialog(DialogTypeEnum.Welcome);


            // voláme javascriptovou metodu leafletu, která inicializuje mapu
            // jako parametr předám informace o vrstvách a počátečním zobrazení mapy
            await JS.InvokeVoidAsync("mapAPI.initMap", MapService.GetMapInfoForLeaflet(mapZoom));

            // tady se zase zjistí, jak je velká oblast, která se zobrazuje na mapě
            MapService.MapZoom = mapZoom == 0 ? await JS.InvokeAsync<float>("mapAPI.getZoom") : mapZoom;
            MapService.SetBBox(await JS.InvokeAsync<Coordinate[]>("mapAPI.getMapBoundsForMapState"));

            if (coordinates != null)
                await ShowPlaceInfo(mapZoom, coordinates, 0);

            // a posledně zmiňované informace se pak použijí pro zobrazení špendlíků a polygonů na mapě
            await MapService.RefreshObjectsOnMap(true);
            await JS.InvokeVoidAsync("mapAPI.showLayersForNormalMap");

            MapService.NotifyStateChanged();
        }

    }

    [JSInvokable("SetMobileView")]
    public void SetMobileView(bool value)
    {
        MapService.IsMobileView = value;
        isMobileView = value;
        MapService.NotifyStateChanged();
        StateHasChanged();
    }

    /// <summary>
    /// Tahle metoda na obnovení špendlíků a polygonů na mapě se volá vždycky z javascriptu, když se s mapou nějak pohne,
    /// protože tady v aplikaci nemám spolehlivý přehled o tom, kdy se mapa někam pohne, nebo zazoomuje
    /// </summary>
    /// <returns></returns>
    [JSInvokable("RefreshObjectsOnMap")]
    public async Task RefreshObjectsOnMap(bool withPolygons, float zoom, Coordinate[] mapBounds)
    {
        MapService.MapZoom = zoom;
        MapService.SetBBox(mapBounds);
        await MapService.RefreshObjectsOnMap(withPolygons);
        if (!string.IsNullOrEmpty(selectedPointGuidsJson))
        {
            await JS.InvokeVoidAsync("mapAPI.selectPointOnMap", selectedPointGuidsJson);
        }
    }

    public void RemoveObjects(dynamic obj)
    {
        if (!MapService.IsMobileView)
            JS.InvokeVoidAsync("mapAPI.removeAdditionalObjects");
    }

    [JSInvokable("ShowPlaceInfo")]
    public async Task ShowPlaceInfo(float zoom, Coordinate[] coordinates, double mouseClickPointX)
    {
        var placesOnMap = await MapService.GetMapObjects(true, false, coordinates);
        if (placesOnMap.Count == 0)
            return;

        selectedPointGuidsJson = JsonConvert.SerializeObject(placesOnMap.Select(a => a.Guid).ToArray());
        await JS.InvokeVoidAsync("mapAPI.selectPointOnMap", selectedPointGuidsJson);

        var serializerSettings = new JsonSerializerSettings
            {
                ContractResolver = new CamelCasePropertyNamesContractResolver()
            };

        var mapLocationJson = JsonConvert.SerializeObject(new { type = "Point", coordinates = new double[] { coordinates[0].X, coordinates[1].Y } }, serializerSettings);

        await MapService.SetDialog(DialogTypeEnum.Place, new DialogParameters { Places = placesOnMap });

        if (MapService.ShouldBeMapCenteredAfterClick(mouseClickPointX))
            await JS.InvokeVoidAsync("mapAPI.goToLocation", coordinates.AsJson(), MapService.MapZoom);

        await JS.InvokeVoidAsync("mapAPI.setUrlFromSelectedPlace", JsonConvert.SerializeObject(new object[] 
            { 
                new { coordinates[0].Y, coordinates[0].X }, 
                new { coordinates[0].Y, coordinates[0].X } 
            } ));

        MapService.NotifyStateChanged();
    }

    private async Task<Coordinate[]?> GetCoordinatesFromUrl()
    {
        var coordinates = await JS.InvokeAsync<Coordinate[]?>("mapAPI.getSelectedPlaceFromUrl");
        if (coordinates == null || coordinates[0]?.X == null || coordinates[0]?.Y == null || coordinates[1]?.X == null || coordinates[1]?.Y == null)
            return null;
        return coordinates;
    }

}