@page "/"

@using EhriMemoMap.Helpers
@using NetTopologySuite.Geometries;
@using Newtonsoft.Json.Linq;
@using System.Xml;
@using System.Xml.Linq;

@inject IJSRuntime JS
@inject IHttpClientFactory clientFactory
@inject DialogService DialogService
@inject IStringLocalizer<CommonResources> cl
@inject MapStateService MapState
@inject MapLogicService MapLogic
@inject IHttpContextAccessor httpContextAccesor
@inject EhriMemoMap.Data.MemogisContext context

<div id="map" style="cursor:default;">
    <!-- TOTO JE FILTR, KTERÝ SE POUŽÍVÁ PRO HEZČÍ VYKRESLENÍ HRANIC OKRESŮ, 
         RESP. CELÉ PRAHY (viz soubor site.css, řádek div.leaflet-overlay-pane svg > g path.statistics-polygon) -->
    <svg xmlns="w3.org/2000/svg" ; version="1.1">
        <defs>
            <filter id='inset-shadow'>
                <feOffset dx='0' dy='0' />
                <!-- Shadow blur -->
                <feGaussianBlur stdDeviation='5' result='offset-blur' />
                <!-- Invert drop shadow to make an inset shadow -->
                <feComposite operator='out' in='SourceGraphic' in2='offset-blur' result='inverse' />
            </filter>
        </defs>
    </svg>
</div>

<ControlButtonsWrapper />
<ZoomButtonsWrapper />
@if (isMobileBrowser == false)
{
    <LayersQuickAccess />
    <TimelineWrapper />
}
else if (isMobileBrowser == true)
{
    <MobileTopBarWrapper />
}



@code {
    bool? isMobileBrowser = null;
    bool firstRender = true;
    string? selectedPointGuidsJson;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        this.firstRender = firstRender;

        if (firstRender && !MapState.MapStateWasInit)
        {
            // musím do javascriptu šoupnout odkaz na instanci téhle třídy Map,
            // abych pak mohl z javascriptu volat metodu RefreshObjectsOnMap a ShowPlaceInfo

            var dotNetReference = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("mapAPI.initBlazorMapObject", dotNetReference);
            string layers = await JS.InvokeAsync<string>("mapAPI.getUrlParam", "layers");
            string timelinePointName = await JS.InvokeAsync<string>("mapAPI.getUrlParam", "timeline");
            MapState.IsMobileBrowser = await JS.InvokeAsync<bool>("mapAPI.isMobileBrowser");
            MapState.Init(layers, timelinePointName);
            await JS.InvokeVoidAsync("mapAPI.initMap", MapState.GetMapInfoForLeaflet());

            MapState.WindowWidth = await JS.InvokeAsync<int>("mapAPI.getWindowWidth");
            MapState.WindowHeight = await JS.InvokeAsync<int>("mapAPI.getWindowHeight");
            MapState.MapZoom = await JS.InvokeAsync<int>("mapAPI.getZoom");
            MapState.SetBBox(await JS.InvokeAsync<Coordinate[]>("mapAPI.getMapBoundsForMapState"));

            await MapLogic.RefreshObjectsOnMap(true);
            isMobileBrowser = MapState.IsMobileBrowser;

            if (!MapState.IsMobileBrowser)
                DialogService.Open<WelcomeDialog>(" ", options: new DialogOptions { ShowClose = false, ShowTitle = false, CloseDialogOnOverlayClick = true, Width = "33%" });
            else
            {
                MapState.SetDialogType(DialogTypeEnum.Welcome);
                await DialogService.OpenSideAsync<WelcomeDialog>(" ", options: await MapState.GetDialogOptions());
            }

            StateHasChanged();
        }

    }

    /// <summary>
    /// Tahle metoda na obnovení špendlíků a polygonů na mapě se volá vždycky z javascriptu, když se s mapou nějak pohne,
    /// protože tady v aplikaci nemám spolehlivý přehled o tom, kdy se mapa někam pohne, nebo zazoomuje
    /// </summary>
    /// <returns></returns>
    [JSInvokable("RefreshObjectsOnMap")]
    public async Task RefreshObjectsOnMap(bool withPolygons, int zoom, Coordinate[] mapBounds)
    {
        MapState.MapZoom = zoom;
        MapState.SetBBox(mapBounds);
        await MapLogic.RefreshObjectsOnMap(withPolygons);
        if (!string.IsNullOrEmpty(selectedPointGuidsJson))
            await JS.InvokeVoidAsync("mapAPI.selectPointOnMap", selectedPointGuidsJson);

    }

    public void RemoveObjects(dynamic obj)
    {
        if (!MapState.IsMobileBrowser)
            JS.InvokeVoidAsync("mapAPI.removeAdditionalObjects");
    }

    [JSInvokable("ShowPlaceInfo")]
    public async Task ShowPlaceInfo(int zoom, Coordinate[] coordinates)
    {
        var placesOnMap = MapLogic.GetMapObjects(true, coordinates);
        if (placesOnMap.Count == 0)
            return;

        selectedPointGuidsJson = JsonConvert.SerializeObject(placesOnMap.Select(a => a.Guid).ToArray());

        var serializerSettings = new JsonSerializerSettings
            {
                ContractResolver = new CamelCasePropertyNamesContractResolver()
            };
        
        var mapLocationJson = JsonConvert.SerializeObject(new { type = "Point", coordinates = new double[] { coordinates[0].X, coordinates[1].Y } }, serializerSettings);
        
        MapState.SetDialogType(DialogTypeEnum.Place);
        DialogService.OpenSideAsync<PlaceDialog>(null, new Dictionary<string, object> { { "Places", placesOnMap } }, await MapState.GetDialogOptions());
        
        if (MapState.IsMobileBrowser)
            await JS.InvokeVoidAsync("mapAPI.goToLocation", coordinates.AsJson(), zoom);


    }

}